From 90107bb1cc39f995f7fae7262b7d1a6929e91a76 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 6 Jul 2019 14:03:12 -0700
Subject: [PATCH] Chunk neighbour deubg


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index d1556ec338..ef1aaf0f27 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1489,9 +1489,20 @@ public class Chunk implements IChunkAccess {
         this.a(ChunkStatus.a(s));
     }
 
-    public void H() {
+    private final List<Throwable> throwables = new java.util.ArrayList<>();
+
+    public void H(Chunk fromChunk) {
+        if (!org.bukkit.Bukkit.isPrimaryThread()) {
+            MinecraftServer.LOGGER.fatal("Current thread: " + Thread.currentThread() + " is touching the neighbour chunk count asynchronously!", new Throwable());
+            throw new IllegalStateException(); // we log just in case some plugin decides to ignore this.
+        }
+        this.throwables.add(new Throwable("Increment from " + this.D + " to " + (this.D + 1) + ", due to loading chunk " + fromChunk));
         ++this.D;
         if (this.D > 8) {
+            MinecraftServer.LOGGER.fatal("Neighbour count is out of sync! Dumping changes:");
+            for (Throwable throwable : this.throwables) {
+                MinecraftServer.LOGGER.fatal("", throwable);
+            }
             throw new RuntimeException("Error while adding chunk to cache. Too many neighbors");
         } else {
             if (this.J()) {
@@ -1501,13 +1512,27 @@ public class Chunk implements IChunkAccess {
         }
     }
 
-    public void I() {
+    public void I(Chunk fromChunk) {
+        if (!org.bukkit.Bukkit.isPrimaryThread()) {
+            MinecraftServer.LOGGER.fatal("Current thread: " + Thread.currentThread() + " is touching the neighbour chunk count asynchronously!", new Throwable());
+            throw new IllegalStateException(); // we log just in case some plugin decides to ignore this.
+        }
+        this.throwables.add(new Throwable("Decrement from " + this.D + " to " + (this.D - 1) + ", due to unloading chunk " + fromChunk));
         --this.D;
         if (this.D < 0) {
+            MinecraftServer.LOGGER.fatal("Neighbour count is out of sync! Dumping changes:");
+            for (Throwable throwable : this.throwables) {
+                MinecraftServer.LOGGER.fatal("", throwable);
+            }
             throw new RuntimeException("Error while removing chunk from cache. Not enough neighbors");
         }
     }
 
+    @Override
+    public String toString() {
+        return "(" + this.x + ", " + this.z + ") hash:" + this.hashCode();
+    }
+
     public boolean J() {
         return this.D == 8;
     }
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 154ab09e0c..8f43964cab 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -34,8 +34,8 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
                     Chunk chunk2 = (Chunk) super.get(l);  // Paper - use super to avoid polluting last access cache
 
                     if (chunk2 != null) {
-                        chunk.H();
-                        chunk2.H();
+                        chunk.H(chunk);
+                        chunk2.H(chunk);
                     }
                 }
             }
@@ -97,7 +97,7 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
                     Chunk chunk1 = (Chunk) super.get(ChunkCoordIntPair.a(j, k)); // Paper - use super to avoid polluting last access cache
 
                     if (chunk1 != null) {
-                        chunk1.I();
+                        chunk1.I(chunk);
                     }
                 }
             }
-- 
2.22.0

