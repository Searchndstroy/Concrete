From 2ac3649b6701a48f0a8fa90b71a0dee64ed20d70 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 6 Jul 2019 14:03:12 -0700
Subject: [PATCH] Chunk neighbour deubg


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index d1556ec338..0f1ae00a0a 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1489,9 +1489,20 @@ public class Chunk implements IChunkAccess {
         this.a(ChunkStatus.a(s));
     }
 
-    public void H() {
+    private final List<Throwable> throwables = new java.util.ArrayList<>();
+
+    public void H(Chunk fromChunk) {
+        if (!org.bukkit.Bukkit.isPrimaryThread()) {
+            MinecraftServer.LOGGER.fatal("Current thread: " + Thread.currentThread() + " is touching the neighbour chunk count asynchronously!", new Throwable());
+            throw new IllegalStateException(); // we log just in case some plugin decides to ignore this.
+        }
+        this.throwables.add(new Throwable("Increment from " + this.D + " to " + (this.D + 1) + ", due to loading chunk " + fromChunk));
         ++this.D;
         if (this.D > 8) {
+            MinecraftServer.LOGGER.fatal("Neighbour count is out of sync! Dumping changes:");
+            for (Throwable throwable : this.throwables) {
+                MinecraftServer.LOGGER.fatal("", throwable);
+            }
             throw new RuntimeException("Error while adding chunk to cache. Too many neighbors");
         } else {
             if (this.J()) {
@@ -1501,13 +1512,27 @@ public class Chunk implements IChunkAccess {
         }
     }
 
-    public void I() {
+    public void I(Chunk fromChunk) {
+        if (!org.bukkit.Bukkit.isPrimaryThread()) {
+            MinecraftServer.LOGGER.fatal("Current thread: " + Thread.currentThread() + " is touching the neighbour chunk count asynchronously!", new Throwable());
+            throw new IllegalStateException(); // we log just in case some plugin decides to ignore this.
+        }
+        this.throwables.add(new Throwable("Decrement from " + this.D + " to " + (this.D - 1) + ", due to unloading chunk " + fromChunk));
         --this.D;
         if (this.D < 0) {
+            MinecraftServer.LOGGER.fatal("Neighbour count is out of sync! Dumping changes:");
+            for (Throwable throwable : this.throwables) {
+                MinecraftServer.LOGGER.fatal("", throwable);
+            }
             throw new RuntimeException("Error while removing chunk from cache. Not enough neighbors");
         }
     }
 
+    @Override
+    public String toString() {
+        return "(" + this.locX + ", " + this.locZ + ") hash:" + this.hashCode();
+    }
+
     public boolean J() {
         return this.D == 8;
     }
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 154ab09e0c..0cf1b20621 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import java.util.Map;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -9,6 +10,8 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
 
     private static final Logger a = LogManager.getLogger();
 
+    private final ObjectOpenHashSet<Chunk> chunkSet = new ObjectOpenHashSet<>();
+
     public ChunkMap(int i) {
         super(i);
     }
@@ -22,6 +25,9 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
         synchronized (this) {
             // synchronize so any async gets are safe
             chunk1 = (Chunk) super.put(i, chunk);
+            if (!chunkSet.add(chunk)) {
+                MinecraftServer.LOGGER.fatal("Chunk neighbour debug: Double adding chunk reference to chunk map! Chunk: " + chunk + ", report this", new Throwable());
+            }
         }
         if (chunk1 == null) { // Paper - we should never be overwriting chunks
         // Paper end
@@ -34,8 +40,8 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
                     Chunk chunk2 = (Chunk) super.get(l);  // Paper - use super to avoid polluting last access cache
 
                     if (chunk2 != null) {
-                        chunk.H();
-                        chunk2.H();
+                        chunk.H(chunk);
+                        chunk2.H(chunk);
                     }
                 }
             }
@@ -86,6 +92,7 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
         synchronized (this) {
             // synchronize so any async gets are safe
             chunk = super.remove(i);
+            chunkSet.remove(chunk);
         }
         if (chunk != null) { // Paper - don't decrement if we didn't remove anything
         // Paper end
@@ -97,7 +104,7 @@ public class ChunkMap extends Long2ObjectOpenHashMap<Chunk> {
                     Chunk chunk1 = (Chunk) super.get(ChunkCoordIntPair.a(j, k)); // Paper - use super to avoid polluting last access cache
 
                     if (chunk1 != null) {
-                        chunk1.I();
+                        chunk1.I(chunk);
                     }
                 }
             }
-- 
2.22.0

